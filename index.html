<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.70.0" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>전체글보기 </title>
  <meta name="description" content="">
  <meta property="og:title" content="전체글보기">
  
  <meta property="og:type" content="website">
  
  <meta property="og:description" content="">
  <meta property="og:url" content="https://jordi02183.github.io/">
  <meta property="og:site_name" content="전체글보기">
  
  <meta property="og:image" content="https://jordi02183.github.io/images/thumbnail.png">
  
  
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://jordi02183.github.io/">
  <link rel="alternate" type="application/rss+xml" href="https://jordi02183.github.io/index.xml" title="전체글보기" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+KR&display=swap">
  <link rel="stylesheet" href="/css/styles.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXX-X"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-XXXXXXXX-X');
  </script>
  
  
  <script type="text/javascript">
  function toggle_visibility(id) {
    var e = document.getElementById(id);
    if (e.className === 'menu')
      e.className = 'menu hidden';
    else
      e.className = 'menu';
  }
  </script>
</head>
<body>
  <div class="navbar">    
    <div class="logo">
      <a href="/">
        <img src="/images/logo.png" height="42px" />
      </a>
    </div>
    <div class="burger">
      <button onclick="toggle_visibility('menu')">
        <i class="fa fa-bars" aria-hidden="true"></i> 메뉴
      </button>
    </div>
    <div id="menu" class="menu hidden">
      <ul>
        <li><a href="/">전체글보기</a></li>
        <li><a href="/categories">카테고리</a></li>
        <li><a href="/tags">태그</a></li>
        <li><a href="/projects">포트폴리오</a></li>        
      </ul>
      <input class="search" id="search-input" type="search" placeholder="검색어" value="">
    </div>
  </div>
  <div class="container">    


  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/10.dfsbfs/" title="10.그래프의 순회, 깊이우선탐색/너비우선탐색(DFS,BFS)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 17시 11분</time>
        <h1>10.그래프의 순회, 깊이우선탐색/너비우선탐색(DFS,BFS)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/10.dfsbfs/" title="10.그래프의 순회, 깊이우선탐색/너비우선탐색(DFS,BFS)">
      <img src="/images/graph1.png" />
    </a>
  </div>
  
  <div>
    그래프의 순회(graph traversal) 그래프의 순회(graph traversal)란 그래프의 모든 정점과 간선을 검사함으로써 그래프를 탐험하는 조직적인 절차를 말한다. 트리의 순회와 크게 다른 점은 없으나, 부모와 자식의 관계가 명확해 부모-&gt;자식으로만 가면 되는 트리와 다르게 그래프는 한번 방문한 곳을 다시 방문하지 않기 위해 체계적이고 조직적인 방식의 순회 처리과정이 필요하다.
깊이우선탐색(Depth-First Search)   깊이우선탐색은 이진트리에 대한 선위순회와 대응되는 방식의 탐색 유형인데, 선위순회와 마찬가지로 출발지에서 멀어지는 외길 방향으로 진행한다. n개의 정점과 m개의 간선을 가진 그래프의 DFS는 O(n+m)시간이 걸린다.
    
    <a href="/post/10.dfsbfs/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/09.graph/" title="9.그래프 (Graph)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 17시 06분</time>
        <h1>9.그래프 (Graph)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/09.graph/" title="9.그래프 (Graph)">
      <img src="/images/graph1.png" />
    </a>
  </div>
  
  <div>
    그래프(graph) 그래프는 이산수학에서 시작되어, 컴퓨터 공학에서 매우 유용하게 쓰이는 추상 자료형이다. 그래프는 vertex와 edge로 구성된 한정된 자료구조를 의미한다. vertex는 정점, edge는 정점과 정점을 연결하는 간선이다.
실제 우리가 일상에서 접하는 다양한 모델인 지도 모델, 네트워크 모델 등은 모두 그래프를 이용해 추상화할 수 있는 것들이다. 특정 장소에서 얼마나 떨어진 다른 장소들을 선택한다던가, 다른 곳으로 갈 때의 이동 경로를 포함하는 등, 그래프는 정말 끝이 없는 응용이 가능할 정도. 가장 많은 파생개념, 원리, 용어를 가지고 있다(범용성이 넓은 만큼 어렵기도 디지게 어려운 자료구조라는 뜻이다.
    
    <a href="/post/09.graph/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/08.hashtable/" title="8.해시 테이블 (Hash Table)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 17시 00분</time>
        <h1>8.해시 테이블 (Hash Table)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/08.hashtable/" title="8.해시 테이블 (Hash Table)">
      <img src="/images/hash2.png" />
    </a>
  </div>
  
  <div>
    해시 테이블 해시 테이블은 탐색 과정을 단번에(O(1)) 끝낼 수 있는 마법의 단어장이다. 왜 내가 단어장이라고 설명을 하였을까? 해시 테이블을 설명할 수 있는 가장 간단한 예가 단어장이기 때문이다.
예를 들어보자. 단어장에 있는 &lsquo;Hashing&rsquo;이라는 단어를 찾는데 얼마의 시간이 걸릴까? 가장 무식한 사람들은 탐색의 과정이니 첫 페이지부터 Hashing이라는 단어가 나올 때까지 첫 페이지부터 단어를 찾아나가면서 O(n) 시간만에 찾을 것이고, 좀 더 똑똑한 사람은 이진 탐색을 사용해 사전의 중간 부분쭘에 있는, 예를 들면 Moonlight 정도의 단어부터 반반으로 나눠가면서 O(logN)의 시간 만에 단어를 찾을 수 있을 것이다.
    
    <a href="/post/08.hashtable/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/07.avltree/" title="7.균형잡힌 트리, AVL 트리 (AVL Tree)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 16시 46분</time>
        <h1>7.균형잡힌 트리, AVL 트리 (AVL Tree)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/07.avltree/" title="7.균형잡힌 트리, AVL 트리 (AVL Tree)">
      <img src="/images/avltree.png" />
    </a>
  </div>
  
  <div>
    불균형 이진 탐색 트리의 문제점 이진 탐색 트리에서 균형잡힌 트리가 왜 중요할까? : 비뚤게 자란 나무가 좋게 보이지 않는것처럼, 추상 자료형인 트리 또한 비뚤게 자라면 문제가 생긴다. 이진 트리 탐색 과정에서의 효율성(O(log n))이 말도 안되게 떨어지고(O(n), 배열로 구현할 경우에는 심지어 공간 낭비도 심해진다.
  비뚤게 자란 트리의 예
AVL 트리(Adelson-Velskii/Landis Tree) AVL트리는 Adelson-Velskii와 Landis에 의해 1962년 제안된 이진 균형 트리이다. AVL 트리의 핵심 개념은 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이(Height Defference)를 1 이하로 유지한다는 것이다.
    
    <a href="/post/07.avltree/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/06.binarytree/" title="6.이진 탐색 트리 (Binary Search Tree)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 16시 30분</time>
        <h1>6.이진 탐색 트리 (Binary Search Tree)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/06.binarytree/" title="6.이진 탐색 트리 (Binary Search Tree)">
      <img src="/images/binarysearchtree.png" />
    </a>
  </div>
  
  <div>
    이진 탐색 트리(Binary Search Tree) 이진 탐색 트리(Binary Search Tree)는 내부노드에 키 또는 키와 원소쌍을 저장하는 트리이다. 이진 트리는 다음과 같은 성질을 만족한다.
 u와 w가 각각 v의 왼쪽,오른쪽 노드일때, key(u) &lt; key(v) &lt;= key(w)가 성립.  위와 같은 특성 덕분에 우리는 중위 순회를 통해 정렬된 값을 얻을 수 있다.
  이진 탐색 트리 또한 삽입, 탐색, 삭제 세 가지 메소드를 구현해야 하는데, 삽입과 탐색은 아주 쉽게 구현할 수 있지만 삭제가 조금 구현할 때 골치가 아프다.
    
    <a href="/post/06.binarytree/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/05.heap/" title="5.우선순위 큐와 힙 (Prior Queue&amp;Heap)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 14시 34분</time>
        <h1>5.우선순위 큐와 힙 (Prior Queue&amp;Heap)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/05.heap/" title="5.우선순위 큐와 힙 (Prior Queue&amp;Heap)">
      <img src="/images/heap.png" />
    </a>
  </div>
  
  <div>
    우선순위 큐(Prior Queue) 우선순위 큐는 추상자료형의 하나로 일반적인 큐와는 다른 특징을 가진다. 큐는 단순히 먼저 들어간 데이터가 먼저 나오는(선입선출) 특성을 가지고 있지만, 우선순위 큐는 사용자(프로그래머)가 우선순위를 지정할 수 있다.
이 우선순위 큐를 구현하는 것은 기존의 재료였던 배열, 연결리스트에 이어 힙(heap)을 사용할 수 있다. 힙이 왜 필요할까? 배열과 연결리스트로 우선순위 큐를 구현할 때의 단점을 알아보자.
 배열로 구현할 경우 데이터 삽입 및 삭제과정에서 데이터를 한 칸씩 밀어야 하는 연산을 반복해야 한다.(O(n)) 연결리스트로 구현할 경우에도 첫번째 노드부터 마지막 노드까지 저장된 데이터와 우선순위를 비교해야 한다.
    
    <a href="/post/05.heap/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />

  <div class="post">
  <div class="post-title">
    <a href="https://jordi02183.github.io/post/04.tree/" title="4.트리와 트리의 순회 (Tree&amp;Traverse)">
      <img src="/images/post-title-icon.png" />
      <div class="post-meta">
        <time>2020년 5월 14일 14시 20분</time>
        <h1>4.트리와 트리의 순회 (Tree&amp;Traverse)</h1>
      </div>
    </a>
  </div>
  
  <div class="cover-image">
    <a href="https://jordi02183.github.io/post/04.tree/" title="4.트리와 트리의 순회 (Tree&amp;Traverse)">
      <img src="/images/Tree.png" />
    </a>
  </div>
  
  <div>
    트리(Tree) 트리는 첫 번째로 경험할 수 있는, 가장 간단한 비선형 자료구조이다. 트리는 하나의 Root와 0개 이상의 child로 이루어진 노드로 이루어진, 거꾸로 된 나무(tree)구조이다.
트리의 특징
 트리는 하나의 루트 노드를 갖는다. 루트 노드는 0개 이상의 자식 노드를 갖고 있다. 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다. 노드(node)들과 노드들을 연결하는 간선(edge)들로 구성되어 있다. 트리에는 사이클(cycle)이 존재할 수 없다. 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있다.
    
    <a href="/post/04.tree/" class="summary-more">더보기</a>
    
  </div>
</div>

  <hr class="summary-sep" />


<div class="paging">
  
  <span class="page">
    페이지 1 / 2
  </span>
  
  <a href="/page/2/" rel="next">
    <i class="fa fa-caret-right" aria-hidden="true"></i>
    
  </a>
  
</div>


<div class="go-top">
  <a href="#" class="go-top-button">
    <i class="fa fa-angle-double-up"></i>
    <span>위로</span>
  </a>
</div>
<footer class="footer">
  COPYRIGHT (C) <a href="https://blog.lulab.net">DONGGEUN,BANG (LUBANG).</a><br />
  ALL RIGHTS RESERVED.
</footer>
</body>
</html>

