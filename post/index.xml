<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 전체글보기</title>
    <link>https://jordi02183.github.io/post/</link>
    <description>Recent content in Posts on 전체글보기</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>sjc02183@naver.com (ChangHakKim)</managingEditor>
    <webMaster>sjc02183@naver.com (ChangHakKim)</webMaster>
    <lastBuildDate>Thu, 14 May 2020 17:11:42 +0900</lastBuildDate>
    
	<atom:link href="https://jordi02183.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>10.그래프의 순회, 깊이우선탐색/너비우선탐색(DFS,BFS)</title>
      <link>https://jordi02183.github.io/post/10.dfsbfs/</link>
      <pubDate>Thu, 14 May 2020 17:11:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/10.dfsbfs/</guid>
      <description>그래프의 순회(graph traversal) 그래프의 순회(graph traversal)란 그래프의 모든 정점과 간선을 검사함으로써 그래프를 탐험하는 조직적인 절차를 말한다. 트리의 순회와 크게 다른 점은 없으나, 부모와 자식의 관계가 명확해 부모-&amp;gt;자식으로만 가면 되는 트리와 다르게 그래프는 한번 방문한 곳을 다시 방문하지 않기 위해 체계적이고 조직적인 방식의 순회 처리과정이 필요하다.
깊이우선탐색(Depth-First Search)   깊이우선탐색은 이진트리에 대한 선위순회와 대응되는 방식의 탐색 유형인데, 선위순회와 마찬가지로 출발지에서 멀어지는 외길 방향으로 진행한다. n개의 정점과 m개의 간선을 가진 그래프의 DFS는 O(n+m)시간이 걸린다.</description>
    </item>
    
    <item>
      <title>9.그래프 (Graph)</title>
      <link>https://jordi02183.github.io/post/09.graph/</link>
      <pubDate>Thu, 14 May 2020 17:06:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/09.graph/</guid>
      <description>그래프(graph) 그래프는 이산수학에서 시작되어, 컴퓨터 공학에서 매우 유용하게 쓰이는 추상 자료형이다. 그래프는 vertex와 edge로 구성된 한정된 자료구조를 의미한다. vertex는 정점, edge는 정점과 정점을 연결하는 간선이다.
실제 우리가 일상에서 접하는 다양한 모델인 지도 모델, 네트워크 모델 등은 모두 그래프를 이용해 추상화할 수 있는 것들이다. 특정 장소에서 얼마나 떨어진 다른 장소들을 선택한다던가, 다른 곳으로 갈 때의 이동 경로를 포함하는 등, 그래프는 정말 끝이 없는 응용이 가능할 정도. 가장 많은 파생개념, 원리, 용어를 가지고 있다(범용성이 넓은 만큼 어렵기도 디지게 어려운 자료구조라는 뜻이다.</description>
    </item>
    
    <item>
      <title>8.해시 테이블 (Hash Table)</title>
      <link>https://jordi02183.github.io/post/08.hashtable/</link>
      <pubDate>Thu, 14 May 2020 17:00:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/08.hashtable/</guid>
      <description>해시 테이블 해시 테이블은 탐색 과정을 단번에(O(1)) 끝낼 수 있는 마법의 단어장이다. 왜 내가 단어장이라고 설명을 하였을까? 해시 테이블을 설명할 수 있는 가장 간단한 예가 단어장이기 때문이다.
예를 들어보자. 단어장에 있는 &amp;lsquo;Hashing&amp;rsquo;이라는 단어를 찾는데 얼마의 시간이 걸릴까? 가장 무식한 사람들은 탐색의 과정이니 첫 페이지부터 Hashing이라는 단어가 나올 때까지 첫 페이지부터 단어를 찾아나가면서 O(n) 시간만에 찾을 것이고, 좀 더 똑똑한 사람은 이진 탐색을 사용해 사전의 중간 부분쭘에 있는, 예를 들면 Moonlight 정도의 단어부터 반반으로 나눠가면서 O(logN)의 시간 만에 단어를 찾을 수 있을 것이다.</description>
    </item>
    
    <item>
      <title>7.균형잡힌 트리, AVL 트리 (AVL Tree)</title>
      <link>https://jordi02183.github.io/post/07.avltree/</link>
      <pubDate>Thu, 14 May 2020 16:46:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/07.avltree/</guid>
      <description>불균형 이진 탐색 트리의 문제점 이진 탐색 트리에서 균형잡힌 트리가 왜 중요할까? : 비뚤게 자란 나무가 좋게 보이지 않는것처럼, 추상 자료형인 트리 또한 비뚤게 자라면 문제가 생긴다. 이진 트리 탐색 과정에서의 효율성(O(log n))이 말도 안되게 떨어지고(O(n), 배열로 구현할 경우에는 심지어 공간 낭비도 심해진다.
  비뚤게 자란 트리의 예
AVL 트리(Adelson-Velskii/Landis Tree) AVL트리는 Adelson-Velskii와 Landis에 의해 1962년 제안된 이진 균형 트리이다. AVL 트리의 핵심 개념은 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이(Height Defference)를 1 이하로 유지한다는 것이다.</description>
    </item>
    
    <item>
      <title>6.이진 탐색 트리 (Binary Search Tree)</title>
      <link>https://jordi02183.github.io/post/06.binarytree/</link>
      <pubDate>Thu, 14 May 2020 16:30:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/06.binarytree/</guid>
      <description>이진 탐색 트리(Binary Search Tree) 이진 탐색 트리(Binary Search Tree)는 내부노드에 키 또는 키와 원소쌍을 저장하는 트리이다. 이진 트리는 다음과 같은 성질을 만족한다.
 u와 w가 각각 v의 왼쪽,오른쪽 노드일때, key(u) &amp;lt; key(v) &amp;lt;= key(w)가 성립.  위와 같은 특성 덕분에 우리는 중위 순회를 통해 정렬된 값을 얻을 수 있다.
  이진 탐색 트리 또한 삽입, 탐색, 삭제 세 가지 메소드를 구현해야 하는데, 삽입과 탐색은 아주 쉽게 구현할 수 있지만 삭제가 조금 구현할 때 골치가 아프다.</description>
    </item>
    
    <item>
      <title>5.우선순위 큐와 힙 (Prior Queue&amp;Heap)</title>
      <link>https://jordi02183.github.io/post/05.heap/</link>
      <pubDate>Thu, 14 May 2020 14:34:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/05.heap/</guid>
      <description>우선순위 큐(Prior Queue) 우선순위 큐는 추상자료형의 하나로 일반적인 큐와는 다른 특징을 가진다. 큐는 단순히 먼저 들어간 데이터가 먼저 나오는(선입선출) 특성을 가지고 있지만, 우선순위 큐는 사용자(프로그래머)가 우선순위를 지정할 수 있다.
이 우선순위 큐를 구현하는 것은 기존의 재료였던 배열, 연결리스트에 이어 힙(heap)을 사용할 수 있다. 힙이 왜 필요할까? 배열과 연결리스트로 우선순위 큐를 구현할 때의 단점을 알아보자.
 배열로 구현할 경우 데이터 삽입 및 삭제과정에서 데이터를 한 칸씩 밀어야 하는 연산을 반복해야 한다.(O(n)) 연결리스트로 구현할 경우에도 첫번째 노드부터 마지막 노드까지 저장된 데이터와 우선순위를 비교해야 한다.</description>
    </item>
    
    <item>
      <title>4.트리와 트리의 순회 (Tree&amp;Traverse)</title>
      <link>https://jordi02183.github.io/post/04.tree/</link>
      <pubDate>Thu, 14 May 2020 14:20:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/04.tree/</guid>
      <description>트리(Tree) 트리는 첫 번째로 경험할 수 있는, 가장 간단한 비선형 자료구조이다. 트리는 하나의 Root와 0개 이상의 child로 이루어진 노드로 이루어진, 거꾸로 된 나무(tree)구조이다.
트리의 특징
 트리는 하나의 루트 노드를 갖는다. 루트 노드는 0개 이상의 자식 노드를 갖고 있다. 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의된다. 노드(node)들과 노드들을 연결하는 간선(edge)들로 구성되어 있다. 트리에는 사이클(cycle)이 존재할 수 없다. 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있다.</description>
    </item>
    
    <item>
      <title>3.스택과 큐 (Stack&amp;Queue)</title>
      <link>https://jordi02183.github.io/post/03.stactqueue/</link>
      <pubDate>Thu, 14 May 2020 14:10:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/03.stactqueue/</guid>
      <description>스택&amp;amp;큐(Stack&amp;amp;Queue) 스택은 대표적인 후입선출, 큐는 대표적인 선입선출 구조를 가진 자료구조이다.
  사실 이 큐와 스택이라는 건 리스트 또는 배열을 응용한 선형 구조이기 때문에, 리스트에서 더 응용할 코드랄게 크게 없다. 리스트에서 앞에 붙이고 앞으로 나오는 기능만 만들면 스택이고, 앞에 붙이고 뒤로 나오는 기능만 만들면 큐이고, 그 둘을 동시에 장착할 수도 있다(Deque라고 부른다). 기본 리스트/배열 형식에서 조금씩만 응용하면 된다.​
다만 이 스택과 큐는 스택/큐의 활용, 또는 스택/큐 기반의 알고리즘으로 들어가면 조금 복잡해지는데, 대표적으로 배열로 구현할 때 공간을 절약할 수 있는 원형 큐, 큐의 삽입, 제거에서 우선순위를 두는 우선순위 큐 등이 있다.</description>
    </item>
    
    <item>
      <title>2.리스트 (List)</title>
      <link>https://jordi02183.github.io/post/02.list/</link>
      <pubDate>Wed, 13 May 2020 15:46:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/02.list/</guid>
      <description>소개 자료구조의 기본이라고 할 수 있는 리스트는 포인터와 구조체를 다시 한번 이해하는데 큰 도움이 되면서, 앞으로 작성할 수많은 자료구조의 기본이 되기 때문에 꼭 한번은 본인의 손으로 만들어 보는 것을 추천한다.
리스트는 다른 나중에 배울 Stack, Queue, Tree, Graph 등과 같은 다른 자료구조 구현에 활용될 기초 자료구조이다. 자료를 순서대로 한 줄로 저장하는 자료구조. &amp;hellip; 제일 처음 데이터를 가리켜서 Head라고 하고, 제일 마지막 데이터를 가리켜서 Tail이라고 한다. 리스트는 크게 배열(Array) 리스트와 연결(Linked) list로 나눌 수 있다.</description>
    </item>
    
    <item>
      <title>1.빅오(Big-Oh)와 시간복잡도(Time-Complexity)</title>
      <link>https://jordi02183.github.io/post/01.bigo/</link>
      <pubDate>Mon, 11 May 2020 14:46:42 +0900</pubDate>
      <author>sjc02183@naver.com (ChangHakKim)</author>
      <guid>https://jordi02183.github.io/post/01.bigo/</guid>
      <description>소개 한정되어 있는 자원에서 그 자원을 항상 효율적으로 사용해야 할 때, 어떤 알고리즘이 좋은 알고리즘일까? 간단하게 두 가지 기준을 두어보자.
  빠르게 실행되고(실행시간)
  자리를 적게 차지하는(기억장소) 알고리즘
  을 좋은 알고리즘이라고 생각할 수 있다. 실제로 데이터구조와 알고리즘에 대한 공부는 이 분석 방법에 대한 배경지식 없이는 무의미하다고 할 수 있다. 실행시간이 빠르더라도 기억장소 요구량이 크거나, 기억장소 요구량은 많지 않지만 실행시간이 느리다면 좋은 프로그램이라 할 수 없다.
하지만 기억장치 제조기술이 눈부시게 발전하면서 기억장치 제조기술 발전과 기억장치 값 하락이 맞물려 기억장소 활용법에 대해서는 어느정도 관대해지는 경향이 있어 최근의 알고리즘은 실행시간을 줄이는 것을 위주로 하고 있고, Dynamic Programming(다이나믹 프로그래밍)같이 공간을 마구 사용해서 시간복잡도를 줄이는 변태적인 방법까지 사용하고 있다.</description>
    </item>
    
  </channel>
</rss>